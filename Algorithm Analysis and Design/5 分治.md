#分治
> 分治是一种算法思想，递归是分治的一种的常用实现方式。判断是否是分治算法问题的依据包括：问题能否分解、子问题是否独立、子问题能否合并。
![[Pasted image 20241225224313.png]]
# 归并排序
```python
def merge_sort_recursive(arr, left: int = 0, right: int = None):  
    if right is None:  
        right = len(arr) - 1  
    if left < right:  
        mid = (left + right) // 2  
        Sort.merge_sort_recursive(arr, left, mid)  
        Sort.merge_sort_recursive(arr, mid + 1, right)  
        Sort.merge(arr, left, mid, right)  
  
    return arrd
    
def merge(cls, arr, left: int, mid: int, right: int):  
    temp_len = right - left + 1  
    temp_arr = np.zeros(temp_len)  
    i, j, k = left, mid + 1, 0  
  
    while i <= mid and j <= right:  
        if arr[i] < arr[j]:  
            temp_arr[k] = arr[i]  
            i += 1  
        else:  
            temp_arr[k] = arr[j]  
            j += 1  
        k += 1  
  
    while i <= mid:  
        temp_arr[k] = arr[i]  
        i += 1  
        k += 1  
  
    while j <= right:  
        temp_arr[k] = arr[j]  
        j += 1  
        k += 1  
  
    for t in range(temp_len):  
        arr[left + t] = temp_arr[t]  
  
    return
```
# 快速排序
```python
def quick_sort(arr, left: int = 0, right: int = None):  
    if right is None:  
        right = len(arr) - 1  
    if left < right:  
        pivot = Sort.partition(arr, left, right)  
        Sort.quick_sort(arr, left, pivot - 1)  
        Sort.quick_sort(arr, pivot + 1, right)  
  
    return arr  
  
def partition(cls, arr, left, right):  
    i, j = left, right  
    while i < j:  
        while i < j and arr[j] >= arr[left]:  
            j -= 1  
        while i < j and arr[i] <= arr[left]:  
            i += 1  
        arr[i], arr[j] = arr[j], arr[i]  
    arr[i], arr[left] = arr[left], arr[i]  
    return i
```