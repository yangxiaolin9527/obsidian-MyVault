#动态规划
> 运用子问题分解，将满足一定性质（重叠子问题、最优子结构、无后效性）的问题划分为子问题，并通过存储子问题的解避免重复计算从而降低复杂度
# 回溯->记忆化搜索->动态规划
1. 回溯。回溯算法通常并不显式地对问题进行拆解，而是**将求解问题看作一系列决策步骤**，通过**试探和剪枝**，搜索所有可能的解。通常利用递归自顶向下求解，因多次求解重复的子问题导致复杂度高
2. 记忆化搜索。在回溯的基础上，**希望所有的重叠子问题都只被计算一次**。为此，记录每个子问题的解，并在搜索过程中将重叠子问题剪枝。
3. 动态规划。回溯及记忆化搜索都是一种“**自顶向下**”的方法：从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯逐层收集子问题的解，构建出原问题的解。
    与之相反，**动态规划是一种“从底向上”的方法**：从最小子问题的解开始，**迭代地**构建更大子问题的解，直至得到原问题的解，没有回溯过程，只需要和记忆化搜索中一样的技巧：存储已经解决的子问题的解。

# 问题特性
## 术语
与回溯算法一样，动态规划也使用“状态”概念来表示问题求解的特定阶段，每个状态都对应一个子问题以及相应的局部最优解。
- 将数组 `dp` 称为 dp 表，dp[i] 表示状态 i 对应子问题的解。
- 将最小子问题对应的状态称为**初始状态**。
- 将递推公式 dp[i]=dp[i−1]+dp[i−2] 称为**状态转移方程**。
特别地，在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**。

## 最优子结构性质
> 虽然分治、回溯和动态规划中都使用了子问题分解的思想，但是DP侧重于子问题是相互依赖的，在分解过程中会出现许多重叠子问题。

问题的最优解与子问题的最优解存在一定的关系，具体地，问题的最优解中所包含的子问题的解是子问题的最优解，也即**原问题的最优解是从子问题的最优解构建得来的**。
## 无后效性
无后效性是动态规划能够有效解决问题的重要特性之一，定义为：**给定一个确定的状态，它的未来发展只与当前状态（有些问题可以通过扩展状态的定义来解决）有关，而与过去经历的状态无关**。
# 解题思路
## 问题判断
如果一个问题满足决策树模型（也即**问题包含明确的决策概念，并且解是通过一系列决策产生的，那么它就满足决策树模型，通常可以使用回溯来解决**），并具有较为明显的“加分项”：
* 问题包含最大（小）或最多（少）等最优化描述。
* 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系。
和竟可能少的减分项：
* 问题的目标是找出所有可能的解决方案，而不是找出最优解。
* 问题描述中有明显的排列组合的特征，需要返回具体的多个方案。
那么，就可以假设它是一个动态规划问题，并在求解过程中验证它。
## 求解框架
### 明确决策，定义状态，得到DP表
动态规划和回溯过程可以描述为一个决策序列，而状态由所有决策变量构成。它应当包含描述解题进度的所有变量，其包含了足够的信息，能够用来推导出下一个状态。

**每个状态都对应一个子问题**，我们会定义一个 dp 表来存储所有子问题的解，状态的每个独立变量都是 dp 表的一个维度。从本质上看，==dp 表是状态和子问题的解之间的映射。==
### 找出最优子结构，推导状态转移方程
根据定义好的 dp 表，思考原问题和子问题的关系，找出通过子问题的最优解来构造原问题的最优解的方法，即最优子结构。

一旦找到了最优子结构，就可以使用它来构建出状态转移方程。
### 确定边界条件和状态转移顺序
边界条件在动态规划中用于初始化 dp 表，在搜索中用于剪枝。

状态转移顺序的核心是要**保证在计算当前问题的解时，所有它依赖的更小子问题的解都已经被正确地计算出来。**
