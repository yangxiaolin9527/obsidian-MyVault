> 本质是一种暴力搜索（穷举），但是可以与剪枝等技巧结合，缩小解空间
# 算法思想
## DFS、尝试与回退、剪枝
1. 回溯算法通常采用“深度优先搜索”来遍历解空间
2. **之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略**。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择。
3. 复杂的回溯问题通常包含一个或多个约束条件，**约束条件通常可用于“剪枝”**。
## 基本概念
![[Pasted image 20241227162425.png]]
## 代码框架
1. Recursive version
```python
def backtrack(state: State, choices: list[choice], res: list[state]):
    """回溯算法框架"""
    # 判断是否为解
    if is_solution(state):
        # 记录解
        record_solution(state, res)
        # 不再继续搜索
        return
    # 遍历所有选择
    for choice in choices:
        # 剪枝：判断选择是否合法
        if is_valid(state, choice):
            # 尝试：做出选择，更新状态
            make_choice(state, choice)
            backtrack(state, choices, res)
            # 回退：撤销选择，恢复到之前的状态
            undo_choice(state, choice)
```
2. Iterative version
   ![[Pasted image 20241227161722.png]]
   以全排列问题为例，给出具体的实现
   ```python
   def iterative_permutation_v3(choice: List[int]) -> List[List[int]]:  
    res: List[List[int]] = []  
    flag: List[int] = [0] * len(choice)  
    state: List[int] = []  
    k: int = 0  
    n: int = len(choice)  
  
    while k >= 0:  
        while flag[k] < n:  
            c = choice[flag[k]]  
            if c not in state:  
                state.append(c)  
                flag[k] += 1  
                k += 1  
                if len(state) == n:  
                    res.append(state.copy())  
                    k -= 1  
                    state.pop()  
            else:  
                flag[k] += 1  
        # 回溯  
        flag[k] = 0  
        k -= 1  
        state.pop() if (k >= 0) else None  
    return res
    ```
