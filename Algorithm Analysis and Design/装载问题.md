# 问题描述
给定$n$个集装箱，第$i$个集装箱的重量为$w_i$，有一艘船的载重量为$W$，问题是在不超过$W$的前提下，尽可能装下重的集装箱。
由于集装箱问题是从个集装箱里选择一部分集装箱，而对每个集装箱，可装上船，也可不装。假设解可以由向量$(x_1,x_2,…,x_n)$表示，$x:\in\{0,1\}$，$x:=1$表示集装箱$i$被装上船，$x:=0$表示集装箱$i$不装上船。因此集装箱装载问题可以描述如下：
$$
\begin{array}{l}
	\max \sum_{i=1}^n{w_ix_i}\\
	\mathrm{s}. \mathrm{t}.\sum_{i=1}^n{w_ix_i}\le W\\
\end{array}
$$
# 问题求解

## 回溯
```python
def backtrack_loading_1(  
        choice: List[int],  
        available_weight: int,  
        state: List[int] = None,  
        res: Dict = None,  
        depth: int = 0,  
) -> Optional[Dict]:  
    if state is None:  
        state: List[int] = []  
    if res is None:  
        res: Dict = {'max_weight': 0, 'best_choice': []}  
    if depth == len(choice):  
        current_weight: int = sum(state)  
        if current_weight >= res['max_weight']:  
            res['max_weight'] = current_weight  
            res['best_choice'] = state.copy()  
    else:  
        c: int = choice[depth]  
        if c <= available_weight:  
                state.append(c)  
                backtrack_loading_1(choice, available_weight - c, state, res, depth + 1)  
                state.pop()  
        if sum(state) + sum(choice[depth + 1:]) > res['max_weight']:  
            backtrack_loading_1(choice, available_weight, state, res, depth + 1)  
    return res
```
## 分支限界
```python
def improved_fifo_loading(choice: List[int], available_weight: int) -> Dict:  
    living_node_queue: deque = deque()  
    res: Dict = {'max_weight': 0, 'best_choice': []}  
    depth: int = 0  
    max_depth: int = len(choice)  
    current_weight: int = 0  
    residual_weight: int = sum(choice[1:])  
  
    living_node_queue.append(-1)  
    while living_node_queue:  
        constraint_value: int = current_weight + choice[depth]  
        # 对’1‘分支进行约束条件判断  
        if constraint_value <= available_weight:  
            # 'best_choice'实时更新目标函数的下界  
            if constraint_value > res['max_weight']:  
                res['max_weight'] = constraint_value  
            if depth < max_depth - 1:  
                living_node_queue.append(constraint_value)  
        # 对’0‘分支进行限界条件（上界）判断  
        if current_weight + residual_weight > res['max_weight'] and depth < max_depth - 1:  
            living_node_queue.append(current_weight)  
        current_weight = living_node_queue.popleft()  
        if current_weight == -1:  
            if len(living_node_queue) == 0:  
                return res  
            else:  
                living_node_queue.append(-1)  
                current_weight = living_node_queue.popleft()  
                depth += 1  
                residual_weight -= choice[depth]
```
## 动态规划
```python
def dp_loading(weight_list: List[int], available_weight: int) -> int:  
    n: int = len(weight_list)  
    dp: List[List[int]] = [[0] * (available_weight + 1) for _ in range(n + 1)]  
  
    for i in range(1, n + 1):  
        for c in range(1, available_weight + 1):  
            if weight_list[i - 1] <= c:  
                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - weight_list[i - 1]] + weight_list[i - 1])  
            else:  
                dp[i][c] = dp[i - 1][c]  
  
    return dp[n][available_weight]
```