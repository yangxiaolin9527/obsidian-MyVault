> 回溯以**深度优先**搜索一棵树，而分支限界常常以**广度优先**或**最小耗费优先**的方法搜索这棵树。
# 算法思想
## 约束函数与限界函数
1. 约束函数是在优化问题中用于**限制可行解范围的函数**。它规定了**问题的解必须满足的条件**。
2. 限界函数通常在搜索算法中使用，用于确定搜索的边界或剪枝条件。它可以帮助算法在搜索过程中尽早**排除不可能产生最优解**的部分，从而提高搜索效率。
## 考虑因素
1. 对于最值问题，考虑如何估算上/下界（设计限界函数）
2. 如何从活结点列表中选择一个节点进行扩展
   * FIFO
   * MinCost/MaxEarning
3. 如何展开搜索树
   一个节点变成扩展节点时，我们展开从它可到达的所有节点。其中那些不能得到可行解的节点去掉（成为死节点）,把剩下来的节点加到活节点的表中，然后，从这个表中选一个节点作为下一个扩展节点。
## BFS与DFS
```python
def bfs(root_node: TreeNode) -> None:  
    traverse_queue: deque = deque()  
    traverse_queue.append('EOF')  
  
    current_node: Union[TreeNode, str] = root_node  
    while traverse_queue:  
        print(current_node.val, end=' ')  
        if current_node.left:  
            traverse_queue.append(current_node.left)  
        if current_node.right:  
            traverse_queue.append(current_node.right)  
  
        current_node = traverse_queue.popleft()  
        if current_node == 'EOF':  
            print()  
            if len(traverse_queue) == 0:  
                return  
            else:  
                traverse_queue.append('EOF')  
                current_node = traverse_queue.popleft()  
  
  
def dfs(root_node: TreeNode) -> None:  
    if root_node is None:  
        return  
    else:  
        print(root_node.val, end=' ')  
        dfs(root_node.left)  
        dfs(root_node.right)  
  
def dfs_iterative(root_node: TreeNode) -> None:  
    traverse_stack: List[TreeNode] = [root_node]  
    while traverse_stack:  
        current_node: TreeNode = traverse_stack.pop()  
        print(current_node.val, end=' ')  
        if current_node.right:  
            traverse_stack.append(current_node.right)  
        if current_node.left:  
            traverse_stack.append(current_node.left)
```

