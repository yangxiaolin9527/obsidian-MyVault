# 问题描述
给定$n$个物品，第$i$个物品的重量为$wgt[i−1]$、价值为$val[i−1]$ ，和一个容量为$cap$的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。
# 问题求解
## 回溯
```python
def backtrack_knapsack(state: List[bool], value: List[int], weight: List[int], available_weight: int, res: Dict = None,  
                       depth: int = 0):  
    if res is None:  
        res = {'max_value': 0, 'best_choice': []}  
    if depth == len(value):  
        current_value: int = np.dot(state, value)  
        if current_value >= res['max_value']:  
            res['max_value'] = current_value  
            res['best_choice'] = state.copy()  
    else:  
        if weight[depth] <= available_weight:  
            state.append(True)  
            backtrack_knapsack(state, value, weight, available_weight - weight[depth], res, depth + 1)  
            state.pop()  
        # 对于0分支节点，考虑限界条件  
        if np.dot(state, value[:depth]) + sum(value[depth + 1:]) > res['max_value']:  
            state.append(False)  
            backtrack_knapsack(state, value, weight, available_weight, res, depth + 1)  
            state.pop()  
    return res  
  
def greedy_r_calculation(available_weight: int, weight: List[int], value: List[int], depth: int) -> float:  
    rw = available_weight  
    b: float = 0.0  
    idx = depth  
    while idx + 1 < len(weight) and rw >= weight[idx + 1]:  
        rw -= weight[idx + 1]  
        b += value[idx + 1]  
        idx += 1  
    if idx + 1 < len(weight):  
        b += rw * value[idx + 1] / weight[idx + 1]  
    return b  
  
def improved_backtrack_knapsack(state: List[bool], value: List[int], weight: List[int], available_weight: int, res: Dict = None,  
                       depth: int = 0):  
    if res is None:  
        res = {'max_value': 0, 'best_choice': []}  
    if depth == len(value):  
        current_value: int = np.dot(state, value)  
        if current_value >= res['max_value']:  
            res['max_value'] = current_value  
            res['best_choice'] = state.copy()  
    else:  
        if weight[depth] <= available_weight:  
            state.append(True)  
            improved_backtrack_knapsack(state, value, weight, available_weight - weight[depth], res, depth + 1)  
            state.pop()  
        # 对于0分支节点，根据贪心算法，考虑更加紧致的限界条件  
        current_value: int = np.dot(state, value[:depth])  
        r_value: float = greedy_r_calculation(available_weight, weight, value, depth)  
        if current_value + r_value> res['max_value']:  
            state.append(False)  
            improved_backtrack_knapsack(state, value, weight, available_weight, res, depth + 1)  
            state.pop()  
    return res
```

## 分支限界
```python
def improved_knapsack_0or1(value: List[int], weight: List[int], available_weight: int) -> Dict:  
    living_node_queue: deque = deque()  
    res: Dict = {'max_value': 0, 'max_weight': 0}  
    depth: int = 0  
    current_weight: int = 0  
    current_value: int = 0  
    max_depth: int = len(value)  
    max_weight = available_weight  
  
    living_node_queue.append(-1)  
    while living_node_queue:  
        constraint_weight: int = current_weight + weight[depth]  
        constraint_value: int = current_value + value[depth]  
        # 对’1‘分支进行约束条件判断  
        if constraint_weight <= max_weight:  
            # 'best_choice'实时更新目标函数的下界  
            if constraint_value > res['max_value']:  
                res['max_value'] = constraint_value  
                res['max_weight'] = constraint_weight  
            if depth < max_depth - 1:  
                living_node_queue.append((constraint_value, constraint_weight))  
        # 对’0‘分支进行限界条件（上界）判断  
        greedy_r_value: float = greedy_r_calculation(available_weight, weight, value, depth)  
        if current_value + greedy_r_value > res['max_value'] and depth < max_depth - 1:  
            living_node_queue.append((current_value, current_weight))  
        temp_node: Union[Tuple, int] = living_node_queue.popleft()  
        if isinstance(temp_node, int):  
            if len(living_node_queue) == 0:  
                return res  
            else:  
                living_node_queue.append(-1)  
                current_value, current_weight = living_node_queue.popleft()  
                depth += 1  
                available_weight = available_weight - current_weight
```

## 动态规划
### 明确决策，定义状态，得到DP表
对于每个物品来说，不放入背包，背包容量不变；放入背包，背包容量减小。由此可得状态定义：当前物品编号 i 和背包容量 c ，记为 [i,c] 。

状态 [i,c] 对应的子问题为：**前 i 个物品在容量为 c 的背包中的最大价值**，记为 dp[i,c] 。

待求解的是 dp[n,cap] ，因此需要一个尺寸为 (n+1)×(cap+1) 的二维 dp 表。
### 找出最优子结构，推导状态转移方程
当我们做出物品 i 的决策后，剩余的是前 i−1 个物品决策的子问题，可分为以下两种情况。

- **不放入物品 i** ：背包容量不变，状态变化为 [i−1,c] 。
- **放入物品 i** ：背包容量减少 wgt[i−1] ，价值增加 val[i−1] ，状态变化为 [i−1,c−wgt[i−1]] 。

上述分析向我们揭示了本题的最优子结构：**最大价值 dp[i,c] 等于不放入物品 i 和放入物品 i 两种方案中价值更大的那一个**。由此可推导出状态转移方程：

dp[i,c]=max(dp[i−1,c],dp[i−1,c−wgt[i−1]]+val[i−1])

需要注意的是，若当前物品重量 wgt[i−1] 超出剩余背包容量 c ，则只能选择不放入背包。
### 确定边界条件和状态转移顺序
当无物品或背包容量为 0 时最大价值为 0 ，即首列 dp[i,0] 和首行 dp[0,c] 都等于 0 。

当前状态 [i,c] 从上方的状态 [i−1,c] 和左上方的状态 [i−1,c−wgt[i−1]] 转移而来，因此通过两层循环正序遍历整个 dp 表即可。
#### 代码实现
```python
def knapsack_dp(wgt: list[int], val: list[int], cap: int) -> int:
    """0-1 背包：动态规划"""
    n = len(wgt)
    # 初始化 dp 表
    dp = [[0] * (cap + 1) for _ in range(n + 1)]
    # 状态转移
    for i in range(1, n + 1):
        for c in range(1, cap + 1):
            if wgt[i - 1] > c:
                # 若超过背包容量，则不选物品 i
                dp[i][c] = dp[i - 1][c]
            else:
                # 不选和选物品 i 这两种方案的较大值
                dp[i][c] = max(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1])
    return dp[n][cap]
```
